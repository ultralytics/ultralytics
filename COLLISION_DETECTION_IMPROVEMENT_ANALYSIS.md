# ç¢°æ’æ£€æµ‹ç³»ç»Ÿæ”¹è¿›æ–¹æ¡ˆåˆ†æ

**åˆ†ææ—¶é—´**: 2025-01-09  
**åˆ†æäºº**: AI åˆ†æ  
**å¯¼å¸ˆåé¦ˆ**: æ”¹è¿›ç¢°æ’è·ç¦»è®¡ç®—æ–¹æ³•ï¼Œä»ç®€å•çš„ä¸­å¿ƒç‚¹è·ç¦»åˆ°åŸºäºè½¦è¾†å…³é”®é”šç‚¹çš„æŠ•å½±è®¡ç®—

---

## ä¸€ã€å½“å‰ç³»ç»Ÿç°çŠ¶åˆ†æ

### 1.1 ç°æœ‰æ–¹æ³•çš„å±€é™æ€§

#### **é—®é¢˜1ï¼šä¸­å¿ƒç‚¹è·ç¦»è®¡ç®—è¿‡äºç®€åŒ–**

```python
# å½“å‰å®ç° (collision_detection_pipeline_yolo_first_method_a.py, Line 791-792)
distance_meters = np.sqrt((x2_world-x1_world)**2 + (y2_world-y1_world)**2)
```

**é—®é¢˜æ‰€åœ¨**:
- ä»…è®¡ç®—ä¸¤ä¸ªç‰©ä½“ **ä¸­å¿ƒç‚¹ä¹‹é—´çš„ç›´çº¿è·ç¦»**
- å¿½ç•¥ç‰©ä½“çš„**å½¢çŠ¶ã€æ–¹å‘ã€æœå‘**ç­‰å‡ ä½•ä¿¡æ¯
- ä¸¤ä¸ªç‰©ä½“å³ä½¿ä¸­å¿ƒç‚¹å¾ˆè¿‘ï¼Œä¹Ÿå¯èƒ½**ä¸ä¼šå®é™…ç¢°æ’**ï¼ˆæ¯”å¦‚ä¸€è¾†è½¦åœ¨å·¦é“ï¼Œä¸€è¾†åœ¨å³é“ï¼Œä¸”éƒ½åœ¨ç›´çº¿è¡Œé©¶ï¼‰
- ç›¸åï¼Œä¸¤ä¸ªç‰©ä½“å³ä½¿ä¸­å¿ƒç‚¹è¾ƒè¿œï¼Œç”±äº**çªå‡ºéƒ¨åˆ†**ï¼ˆå¦‚è½¦å¤´ã€è½¦å°¾ï¼‰ä¹Ÿå¯èƒ½**çœŸæ­£ç¢°æ’**

#### **é—®é¢˜2ï¼šæ— æ³•å¤„ç†å¤æ‚äº¤å‰åœºæ™¯**

ä»¥ä½ æä¾›çš„å›¾åƒä¸ºä¾‹ï¼š
```
æ·±ç°è‰²çš®å¡ï¼ˆä¸Šæ–¹ï¼‰ â† é€æ¸é è¿‘
    â†“
é“¶è‰²å°è½¿è½¦ï¼ˆä¸‹æ–¹ï¼Œå¹¶å…¥è½¦é“ï¼‰
```

**å½“å‰ç³»ç»Ÿçš„é—®é¢˜**ï¼š
- ä»…è®¡ç®—ä¸¤è½¦**ä¸­å¿ƒç‚¹è·ç¦»** â‰ˆ 3.47mï¼ˆå¦‚å›¾æ‰€ç¤ºï¼‰
- ä½†å®é™…é£é™©æ¥è‡ªäºï¼š
  - ä¸‹æ–¹è½¦çš„**è½¦å¤´å³ä¾§** â† å¯èƒ½ä¸
  - ä¸Šæ–¹çš®å¡çš„**å·¦åè½¦å°¾** â† å‘ç”Ÿç¢°æ’

**è¿™ä¸¤ä¸ªå…³é”®éƒ¨ä½ä¹‹é—´çš„è·ç¦»** è¿œå°äºä¸­å¿ƒç‚¹è·ç¦»ï¼

#### **é—®é¢˜3ï¼šæ— æ³•åŒºåˆ†æ¥è¿‘æ–¹å‘**

- å½“å‰ç³»ç»Ÿæ— æ³•åˆ¤æ–­ï¼šè½¦è¾†æ˜¯**ä¾§å‘æ¥è¿‘**ï¼ˆæœ‰ç¢°æ’é£é™©ï¼‰è¿˜æ˜¯**çºµå‘æ¥è¿‘**ï¼ˆå¯èƒ½åªæ˜¯é€Ÿåº¦å·®å¼‚ï¼‰
- æ²¡æœ‰åˆ©ç”¨è½¦è¾†çš„**æœå‘ä¿¡æ¯**ï¼ˆheadingï¼‰

---

## äºŒã€æ”¹è¿›æ–¹æ¡ˆï¼šé”šç‚¹æŠ•å½±ç¢°æ’æ£€æµ‹

### 2.1 æ ¸å¿ƒæ¦‚å¿µ

#### **å®šä¹‰ï¼šç‰©ä½“é”šç‚¹ï¼ˆObject Anchor Pointsï¼‰**

ä¸æ˜¯ç”¨å•ä¸ªä¸­å¿ƒç‚¹ï¼Œè€Œæ˜¯å®šä¹‰ç‰©ä½“çš„**å¤šä¸ªå…³é”®ä½ç½®ç‚¹**ï¼Œæ ¹æ®ç‰©ä½“ç±»å‹è€Œå¼‚ï¼š

##### **æ±½è½¦/è½¦è¾†ç±»å‹**:
```
        y
        â†‘
        |  [è½¦å¤´ä¸­ç‚¹ - Front]
        |   â€¢ â€¢
        |  â€¢ â€¢ â€¢  (w/2, h/2)
        |
   -----+-------- â†’ x
        |
        |  â€¢ â€¢ â€¢  (w/2, -h/2)
        |   â€¢ â€¢
        |  [è½¦å°¾ä¸­ç‚¹ - Rear]

æ ‡å‡†8ä¸ªé”šç‚¹ï¼š
1. front_center:     (x, y + h/2)      [è½¦å¤´ä¸­ç‚¹]
2. front_left:       (x - w/2, y + h/2) [è½¦å¤´å·¦è§’]
3. front_right:      (x + w/2, y + h/2) [è½¦å¤´å³è§’]
4. rear_center:      (x, y - h/2)      [è½¦å°¾ä¸­ç‚¹]
5. rear_left:        (x - w/2, y - h/2) [è½¦å°¾å·¦è§’]
6. rear_right:       (x + w/2, y - h/2) [è½¦å°¾å³è§’]
7. left_center:      (x - w/2, y)      [å·¦ä¾§ä¸­ç‚¹]
8. right_center:     (x + w/2, y)      [å³ä¾§ä¸­ç‚¹]
```

##### **äººç±»ï¼ˆè¡Œäººï¼‰**:
```
ç®€åŒ–4ä¸ªé”šç‚¹ï¼š
1. head:    (x, y - h/2)     [å¤´éƒ¨]
2. torso:   (x, y)           [èº¯å¹²ä¸­å¿ƒ]
3. lower:   (x, y + h/2)     [ä¸‹èº«/è…¿éƒ¨]
4. feet:    (x, y + h/2)     [è„šéƒ¨]
```

### 2.2 æ”¹è¿›æ–¹æ³•ï¼šå¤šé”šç‚¹è·ç¦»è®¡ç®—

#### **æ–¹æ³•è®º**

```python
# ä¼ªä»£ç æ¦‚å¿µ
def calculate_collision_risk(vehicle1, vehicle2):
    """
    è®¡ç®—ä¸¤ä¸ªç‰©ä½“ä¹‹é—´çš„ç¢°æ’é£é™©
    """
    # Step 1: è·å–ä¸¤ä¸ªç‰©ä½“çš„æ‰€æœ‰é”šç‚¹
    anchors_v1 = get_vehicle_anchors(vehicle1)  # vehicle1çš„8ä¸ªç‚¹
    anchors_v2 = get_vehicle_anchors(vehicle2)  # vehicle2çš„8ä¸ªç‚¹
    
    # Step 2: è®¡ç®—æ‰€æœ‰é”šç‚¹å¯¹ä¹‹é—´çš„è·ç¦»
    min_distance = float('inf')
    closest_pair = None
    
    for anchor1 in anchors_v1:
        for anchor2 in anchors_v2:
            # è®¡ç®—è¿™ä¸¤ä¸ªé”šç‚¹ä¹‹é—´çš„è·ç¦»
            dist = calculate_distance(anchor1, anchor2)
            
            if dist < min_distance:
                min_distance = dist
                closest_pair = (anchor1, anchor2)
    
    # Step 3: è¿”å›æœ€å°è·ç¦»å’Œæœ€æ¥è¿‘çš„ç‚¹å¯¹
    return min_distance, closest_pair
```

**å…³é”®ä¼˜åŠ¿**:
- âœ… å‘ç° **çœŸå®çš„æœ€æ¥è¿‘éƒ¨ä½**
- âœ… åŒæ—¶å¾—åˆ° **å“ªä¸¤ä¸ªéƒ¨åˆ†æœ€æ¥è¿‘** çš„ä¿¡æ¯
- âœ… å¯è®¡ç®—æ›´ç²¾ç»†çš„é£é™©è¯„çº§

---

## ä¸‰ã€åº”ç”¨åœºæ™¯åˆ†æ

### 3.1 åœºæ™¯1ï¼šå¤šè½¦é“å¹¶å…¥ï¼ˆå›¾ä¸­åœºæ™¯ï¼‰

```
ä¿¯è§†å›¾ç¤ºæ„ï¼š
      [çš®å¡è½¦é“]
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ æ·±ç°çš®å¡ â”‚  â† è½¦å¤´åœ¨è§†é¢‘ä¸‹æ–¹
    â””â”€â”€â”€â”€â†’â”€â”€â”€â”€â”˜
         â†‘
         |  å¹¶å…¥
      [å°è½¦é“]
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ é“¶è‰²å°è½¦ â”‚  â†’ å‘å³ä¸Šæ–¹å¹¶å…¥
    â””â”€â”€â”€â”€â†’â”€â”€â”€â”€â”˜
```

**å½“å‰ç³»ç»Ÿï¼ˆä¸­å¿ƒç‚¹ï¼‰**:
```
çš®å¡ä¸­å¿ƒ: (500, 200)
å°è½¦ä¸­å¿ƒ: (350, 350)
è·ç¦» = âˆš[(500-350)Â² + (200-350)Â²] â‰ˆ 212px â‰ˆ 3.47m
åˆ¤å®š: æ¥è¿‘ä½†ä¸ç¢°æ’
```

**æ”¹è¿›ç³»ç»Ÿï¼ˆå¤šé”šç‚¹ï¼‰**:
```
çš®å¡çš„å‡ ä¸ªå…³é”®ç‚¹ï¼š
- rear_left:  (480, 240)     â† å·¦åè½¦å°¾
- rear_right: (520, 240)

å°è½¦çš„å‡ ä¸ªå…³é”®ç‚¹ï¼š
- front_left:  (330, 330)    â† è½¦å¤´å·¦è§’
- front_right: (370, 330)    â† è½¦å¤´å³è§’

æœ€è¿‘çš„ä¸¤ä¸ªç‚¹è·ç¦»ï¼š
dist(rear_left, front_left) = âˆš[(480-330)Â² + (240-330)Â²] â‰ˆ 165px â‰ˆ 2.7m
dist(rear_left, front_right) = âˆš[(480-370)Â² + (240-330)Â²] â‰ˆ 140px â‰ˆ 2.3m  â† æœ€å°

åˆ¤å®š: "çš®å¡å·¦åè½¦å°¾ â†” å°è½¦è½¦å¤´å³ä¾§" è·ç¦»æœ€æ¥è¿‘ï¼Œé£é™©æœ€é«˜
```

**å¾—å‡ºçš„ç»“è®º**:
- æœ€æ¥è¿‘çš„éƒ¨ä½ä¸æ˜¯ä¸­å¿ƒç‚¹
- å¯è­¦å‘Šï¼š"è½¦å¤´å³ä¾§é è¿‘å·¦åè½¦å°¾"ï¼Œæ¯”ä¾‹æ›´ç²¾ç¡®

---

### 3.2 åœºæ™¯2ï¼šè½¦è¾†-è¡Œäººäº’åŠ¨

```
ä¾‹å¦‚ï¼šæ ¡å›­å†…åœè½¦åœº
  [æ±½è½¦]
   â”€â”€â”€â”€â”€â”€â”€â”€
   â€¢ â€¢ â€¢ â€¢  â† è½¦çš„ä¸‹æ–¹4ä¸ªé”šç‚¹
   
   [è¡Œäºº] â† å¯èƒ½åœ¨è½¦ä¸‹æ–¹å³ä¾§èµ°è¿‡
    |
   (Ã—)  â† è¡Œäººå¤´éƒ¨/èº¯å¹²
    |
```

**è®¡ç®—é€»è¾‘**:
```python
# æ£€æŸ¥è¡Œäººçš„å“ªä¸ªéƒ¨ä½æœ€æ¥è¿‘è½¦çš„å“ªä¸ªéƒ¨ä½
min_dist = min(
    distance(car_lower_points, pedestrian_head_points),      # è½¦åº• â†” è¡Œäººå¤´
    distance(car_lower_points, pedestrian_torso_points),     # è½¦åº• â†” è¡Œäººèº¯å¹²  
    distance(car_right_points, pedestrian_points),           # è½¦å³ä¾§ â†” è¡Œäºº
)
```

---

### 3.3 åœºæ™¯3ï¼šæœºåŠ¨è½¦ä¸éæœºåŠ¨è½¦ï¼ˆè‡ªè¡Œè½¦/æ‘©æ‰˜è½¦ï¼‰

```
åœºæ™¯ï¼šè‡ªè¡Œè½¦é è¿‘æ±½è½¦ï¼ˆæ¯”å¦‚åœ¨è½¦çš„å³ä¾§è¶…è½¦ï¼‰

    [æ±½è½¦]
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ front_r â”‚  (x+w/2, y+h/2)
  â”‚         â”‚
  â”‚ right_c â”‚  (x+w/2, y)  â† å…³é”®ç›‘æ§ç‚¹
  â”‚         â”‚
  â”‚ rear_r  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†— [è‡ªè¡Œè½¦é è¿‘]
```

**å…³é”®ç‚¹**:
- å¿…é¡»ç›‘æ§è½¦è¾†çš„ **right_center** ç­‰ä¾§é¢é”šç‚¹
- è‡ªè¡Œè½¦çš„ **è½¦æŠŠã€è½¦è½®ã€è½¦ä½“** ç­‰éƒ¨ä½ä¸è½¦ä¾§é¢çš„æœ€å°è·ç¦»

---

## å››ã€æŠ€æœ¯å®ç°æ¡†æ¶

### 4.1 æ•°æ®ç»“æ„è®¾è®¡

```python
# é”šç‚¹å®šä¹‰
class VehicleAnchors:
    """è½¦è¾†çš„8ä¸ªæ ‡å‡†é”šç‚¹"""
    
    @staticmethod
    def get_anchors(bbox_xywh, object_class, is_front_facing=True):
        """
        Args:
            bbox_xywh: [center_x, center_y, width, height]
            object_class: ç‰©ä½“ç±»åˆ« (0=person, 2=car, 3=motorcycle, etc.)
            is_front_facing: è½¦æ˜¯å¦æ­£å‘ï¼ˆåŸºäºè½¨è¿¹å†å²åˆ¤æ–­ï¼‰
        
        Returns:
            dict of anchor_points {name: (x, y)}
        """
        x, y, w, h = bbox_xywh
        
        if object_class == 2:  # car
            return {
                'front_center': (x, y + h/2),
                'front_left': (x - w/2, y + h/2),
                'front_right': (x + w/2, y + h/2),
                'rear_center': (x, y - h/2),
                'rear_left': (x - w/2, y - h/2),
                'rear_right': (x + w/2, y - h/2),
                'left_center': (x - w/2, y),
                'right_center': (x + w/2, y),
            }
        elif object_class == 0:  # person
            return {
                'head': (x, y - h/2),
                'torso': (x, y),
                'lower': (x, y + h/3),
                'feet': (x, y + h/2),
            }
        # ... å…¶ä»–ç±»åˆ«


class CollisionAnalyzer:
    """ç¢°æ’åˆ†æå™¨"""
    
    @staticmethod
    def get_min_distance_and_parts(obj1, obj2, anchors1, anchors2):
        """
        è®¡ç®—ä¸¤ä¸ªç‰©ä½“æœ€æ¥è¿‘çš„éƒ¨ä½åŠè·ç¦»
        
        Returns:
            {
                'min_distance': float,
                'part1': str,        # ç‰©ä½“1çš„éƒ¨ä½åç§°
                'part2': str,        # ç‰©ä½“2çš„éƒ¨ä½åç§°
                'point1': (x, y),
                'point2': (x, y),
                'risk_level': 'critical' | 'high' | 'medium' | 'low'
            }
        """
        min_dist = float('inf')
        result = None
        
        for part1_name, point1 in anchors1.items():
            for part2_name, point2 in anchors2.items():
                dist = np.sqrt((point1[0] - point2[0])**2 + 
                              (point1[1] - point2[1])**2)
                
                if dist < min_dist:
                    min_dist = dist
                    result = {
                        'min_distance': dist,
                        'part1': part1_name,
                        'part2': part2_name,
                        'point1': point1,
                        'point2': point2,
                    }
        
        return result
```

### 4.2 é›†æˆåˆ°ç°æœ‰æµç¨‹

```
å½“å‰ç®¡é“:
æ£€æµ‹ â†’ è½¨è¿¹æ„å»º â†’ [ä¸­å¿ƒç‚¹è·ç¦»] â†’ å…³é”®å¸§æå– â†’ é½æ¬¡å˜æ¢ â†’ TTCåˆ†æ

æ”¹è¿›å:
æ£€æµ‹ â†’ è½¨è¿¹æ„å»º â†’ [å¤šé”šç‚¹è·ç¦»] â†’ å…³é”®å¸§æå– â†’ é½æ¬¡å˜æ¢ â†’ TTCåˆ†æ
                   â†‘ æ–°å¢ï¼šè®¡ç®—æ‰€æœ‰é”šç‚¹å¯¹ä¹‹é—´çš„è·ç¦»
                   â†‘ è¿”å›æœ€æ¥è¿‘éƒ¨ä½å’Œè·ç¦»
```

**åœ¨ `extract_key_frames()` ä¸­çš„æ”¹åŠ¨ç‚¹**:

```python
# OLD (line 791-792)
distance_meters = np.sqrt((x2_world-x1_world)**2 + (y2_world-y1_world)**2)

# NEW
anchors_obj1 = VehicleAnchors.get_anchors(obj1['bbox_xywh'], obj1['class'])
anchors_obj2 = VehicleAnchors.get_anchors(obj2['bbox_xywh'], obj2['class'])

collision_info = CollisionAnalyzer.get_min_distance_and_parts(
    obj1, obj2, anchors_obj1, anchors_obj2
)

distance_meters = collision_info['min_distance']
closest_parts = (collision_info['part1'], collision_info['part2'])
```

---

## äº”ã€æ–¹å‘ä¼°è®¡å’Œæœå‘é—®é¢˜

### 5.1 è½¦è¾†æœå‘çš„é‡è¦æ€§

**é—®é¢˜**ï¼šä»…æœ‰ bbox çš„ä¸­å¿ƒå’Œå¤§å°ï¼Œå¦‚ä½•ç¡®å®šè½¦çš„"å‰"å’Œ"å"ï¼Ÿ

#### **è§£å†³æ–¹æ¡ˆAï¼šåŸºäºè½¨è¿¹é€Ÿåº¦å‘é‡**

```python
def estimate_vehicle_heading(track_history):
    """ä»è½¨è¿¹å†å²ä¼°è®¡è½¦è¾†æœå‘"""
    
    # ä½¿ç”¨æœ€è¿‘çš„å‡ ä¸ªç‚¹è®¡ç®—é€Ÿåº¦å‘é‡
    recent_points = track_history[-5:]  # æœ€å5å¸§
    
    if len(recent_points) >= 2:
        # é€Ÿåº¦å‘é‡
        vx = recent_points[-1]['x'] - recent_points[0]['x']
        vy = recent_points[-1]['y'] - recent_points[0]['y']
        
        # æœå‘è§’åº¦ï¼ˆç›¸å¯¹äºæ­£xè½´ï¼‰
        heading = np.arctan2(vy, vx)  # å¼§åº¦
        
        # åˆ¤æ–­æ–¹å‘
        if heading < -np.pi/2 or heading > np.pi/2:
            vehicle_orientation = 'backward'  # å€’è¡Œ
        else:
            vehicle_orientation = 'forward'   # å‰è¿›
        
        return heading, vehicle_orientation
    
    return None, 'unknown'
```

**ä¼˜ç‚¹**:
- âœ… è‡ªåŠ¨ä¸”å®æ—¶
- âœ… åˆ©ç”¨å·²æœ‰çš„è½¨è¿¹æ•°æ®

**ç¼ºç‚¹**:
- âŒ æ–°æ£€æµ‹çš„ç‰©ä½“æ²¡æœ‰å†å²ï¼ˆéœ€è¦å‡ å¸§æ‰èƒ½åˆ¤æ–­ï¼‰
- âŒ åœæ­¢æˆ–ç¼“æ…¢ç§»åŠ¨çš„è½¦è¾†æ–¹å‘ä¸ç¡®å®š

---

#### **è§£å†³æ–¹æ¡ˆBï¼šåŸºäº YOLO çš„æ–¹å‘æ ‡æ³¨**ï¼ˆæ›´ç²¾ç¡®ä½†éœ€é¢å¤–æ ‡æ³¨ï¼‰

```python
# å¦‚æœæ”¹è¿› YOLO æ¨¡å‹ä»¥è¾“å‡ºæ–¹å‘ä¿¡æ¯
# å¯ä»¥ç›´æ¥ä»æ£€æµ‹ç»“æœè·å–
def get_heading_from_yolo(detection_result):
    """
    å¦‚æœYOLOè¾“å‡ºåŒ…å«æ–¹å‘è§’åº¦ï¼ˆéœ€è¦è®­ç»ƒæ”¹è¿›ï¼‰
    å¯ä»¥ç›´æ¥ä½¿ç”¨
    
    Format: [x, y, w, h, heading_angle]
    """
    heading = detection_result['heading_angle']  # åº¦æ•°æˆ–å¼§åº¦
    return heading
```

---

#### **è§£å†³æ–¹æ¡ˆCï¼šæ··åˆæ–¹æ¡ˆï¼ˆå®ç”¨æ€§æœ€å¼ºï¼‰**

```python
def get_vehicle_heading(detection, track_history=None):
    """
    ä¼˜å…ˆçº§é¡ºåºè·å–è½¦è¾†æœå‘ï¼š
    1. å¦‚æœYOLOè¾“å‡ºäº†ï¼ˆæœ€å‡†ç¡®ï¼‰
    2. å¦åˆ™ä»è½¨è¿¹å†å²ä¼°è®¡ï¼ˆå¦‚æœè½¨è¿¹è¶³å¤Ÿé•¿ï¼‰
    3. å¦åˆ™ä½¿ç”¨é»˜è®¤æ–¹å‘ï¼ˆä¸ç¡®å®šï¼‰
    """
    
    # ä¼˜å…ˆä½¿ç”¨YOLOè¾“å‡º
    if 'heading' in detection:
        return detection['heading'], 'yolo_direct'
    
    # å…¶æ¬¡ä½¿ç”¨è½¨è¿¹æ¨æ–­
    if track_history and len(track_history) >= 3:
        heading, orientation = estimate_vehicle_heading(track_history)
        return heading, 'trajectory_inferred'
    
    # æœ€åä½¿ç”¨é»˜è®¤
    return 0, 'unknown'
```

---

## å…­ã€æ›´æ–°çš„äº‹ä»¶è®°å½•æ ¼å¼

### 6.1 å½“å‰æ ¼å¼ï¼ˆä¸­å¿ƒç‚¹è·ç¦»ï¼‰

```json
{
  "frame": 123,
  "track_id_1": 5,
  "track_id_2": 8,
  "class_1": "car",
  "class_2": "car",
  "distance_pixel": 150.5,
  "distance_meters": 2.46,
  "center_1_px": [500, 200],
  "center_2_px": [350, 350]
}
```

### 6.2 æ”¹è¿›åçš„æ ¼å¼ï¼ˆå¤šé”šç‚¹ï¼‰

```json
{
  "frame": 123,
  "track_id_1": 5,
  "track_id_2": 8,
  "class_1": "car",
  "class_2": "car",
  
  "distance_analysis": {
    "center_to_center": {
      "distance_meters": 2.46,
      "distance_pixel": 150.5
    },
    "closest_parts": {
      "distance_meters": 1.8,
      "distance_pixel": 115.2,
      "object1_part": "rear_left",      // çš®å¡çš„å·¦åè§’
      "object2_part": "front_right",    // å°è½¦çš„å³å‰è§’
      "object1_point_px": [480, 240],
      "object2_point_px": [370, 330],
      "risk_description": "è½¦å¤´å³ä¾§é è¿‘å·¦åè½¦å°¾"
    },
    "heading_analysis": {
      "object1_heading": 1.2,           // å¼§åº¦
      "object2_heading": 0.8,
      "relative_angle": 0.4,
      "approach_direction": "converging" // æ”¶æ•›ã€å¹³è¡Œã€åˆ†æ•£
    }
  },
  
  "risk_assessment": {
    "primary_risk": "critical",         // åŸºäºæœ€æ¥è¿‘éƒ¨ä½
    "collision_likelihood": 0.85,       // 0-1 ä¹‹é—´ï¼ŒåŸºäºè·ç¦»+é€Ÿåº¦+æ–¹å‘
    "estimated_ttc": 1.2                // é¢„è®¡ç¢°æ’æ—¶é—´ï¼ˆç§’ï¼‰
  }
}
```

---

## ä¸ƒã€è®¡ç®—æµç¨‹å®Œæ•´ç¤ºä¾‹

### ç¤ºä¾‹ï¼šå›¾ä¸­çš„çš®å¡+å°è½¦åœºæ™¯

```python
# Step 1: è·å–ä¸¤è½¦çš„ bbox
obj1 = {  # æ·±ç°çš®å¡ï¼ˆä¸Šæ–¹ï¼‰
    'track_id': 5,
    'class': 2,  # car
    'bbox_xywh': [500, 200, 100, 150]  # x, y, w, hï¼ˆåƒç´ ï¼‰
}

obj2 = {  # é“¶è‰²å°è½¦ï¼ˆä¸‹æ–¹ï¼Œå¹¶å…¥ï¼‰
    'track_id': 8,
    'class': 2,  # car
    'bbox_xywh': [350, 350, 80, 120]
}

# Step 2: ä¼°è®¡æœå‘ï¼ˆä»è½¨è¿¹å†å²ï¼‰
heading1 = estimate_vehicle_heading(tracks[5])  # â†’ çº¦ 0.0 (å‘å³ä¸Š)
heading2 = estimate_vehicle_heading(tracks[8])  # â†’ çº¦ 0.3 (å‘å³ä¸Šï¼Œä½†è§’åº¦æ›´å¤§)

# Step 3: è·å–é”šç‚¹ï¼ˆè€ƒè™‘æœå‘ï¼‰
anchors1 = VehicleAnchors.get_anchors(obj1['bbox_xywh'], 2)
# {
#   'front_center': (500, 275),     // y + h/2 = 200 + 150/2
#   'front_left': (450, 275),
#   'front_right': (550, 275),
#   'rear_center': (500, 125),      // y - h/2 = 200 - 150/2
#   'rear_left': (450, 125),
#   'rear_right': (550, 125),
#   'left_center': (450, 200),
#   'right_center': (550, 200),
# }

anchors2 = VehicleAnchors.get_anchors(obj2['bbox_xywh'], 2)
# {
#   'front_center': (350, 410),
#   'front_left': (310, 410),
#   'front_right': (390, 410),
#   'rear_center': (350, 290),
#   'rear_left': (310, 290),
#   'rear_right': (390, 290),
#   'left_center': (310, 350),
#   'right_center': (390, 350),
# }

# Step 4: è®¡ç®—æ‰€æœ‰é”šç‚¹å¯¹è·ç¦»å¹¶æ‰¾æœ€å°å€¼
distances = []
for name1, pt1 in anchors1.items():
    for name2, pt2 in anchors2.items():
        dist = np.sqrt((pt1[0]-pt2[0])**2 + (pt1[1]-pt2[1])**2)
        distances.append({
            'part1': name1,
            'part2': name2,
            'distance_px': dist
        })

# æ’åºæ‰¾æœ€å°è·ç¦»
distances.sort(key=lambda x: x['distance_px'])
min_result = distances[0]

# min_result å¯èƒ½æ˜¯ï¼š
# {
#   'part1': 'rear_left',      â† çš®å¡çš„å·¦åè§’
#   'part2': 'front_right',    â† å°è½¦çš„å³å‰è§’
#   'distance_px': 115.2       â‰ˆ 1.89m
# }

# Step 5: é½æ¬¡å˜æ¢ï¼ˆä»åƒç´ è½¬ä¸–ç•Œåæ ‡ï¼‰
# ä½¿ç”¨ Homography çŸ©é˜µè½¬æ¢é”šç‚¹åæ ‡
pt1_world = cv2.perspectiveTransform(...) 
pt2_world = cv2.perspectiveTransform(...)
distance_world = np.sqrt((pt1_world[0] - pt2_world[0])**2 + 
                         (pt1_world[1] - pt2_world[1])**2)

# Step 6: ç”Ÿæˆäº‹ä»¶è®°å½•
event = {
    'frame': 123,
    'closest_parts': {
        'distance_meters': distance_world,
        'object1_part': 'rear_left',
        'object2_part': 'front_right',
    },
    'risk_description': f"{obj1['class_name']} çš„ rear_left ä¸ {obj2['class_name']} çš„ front_right æœ€æ¥è¿‘"
}
```

---

## å…«ã€ä¼˜å…ˆçº§å’Œå®ç°è·¯çº¿å›¾

### ä¼˜å…ˆçº§æ’åº

| ä¼˜å…ˆçº§ | æ”¹è¿›é¡¹ | å¤æ‚åº¦ | æ•ˆæœæå‡ | å»ºè®®æ—¶é—´ |
|-------|--------|--------|----------|----------|
| ğŸ”´ **P0** | å¤šé”šç‚¹è·ç¦»è®¡ç®— | ä¸­ç­‰ | **é«˜** | 1-2å‘¨ |
| ğŸ”´ **P0** | æœå‘ä¼°è®¡ï¼ˆè½¨è¿¹æ³•ï¼‰ | ç®€å• | ä¸­ç­‰ | 3-5å¤© |
| ğŸŸ¡ **P1** | æ”¹è¿›äº‹ä»¶è®°å½•æ ¼å¼ | ç®€å• | ä¸­ç­‰ | 2-3å¤© |
| ğŸŸ¡ **P1** | TTC æ”¹è¿›ï¼ˆåŸºäºé”šç‚¹ï¼‰ | ä¸­ç­‰ | ä¸­ç­‰ | 1å‘¨ |
| ğŸŸ¢ **P2** | YOLO æœå‘æ£€æµ‹è®­ç»ƒ | **é«˜** | **å¾ˆé«˜** | 2-4å‘¨ |
| ğŸŸ¢ **P2** | 3D ç¢°æ’æ£€æµ‹ï¼ˆç‰©ç†å¼•æ“ï¼‰ | **å¾ˆé«˜** | å¾ˆé«˜ | 4-8å‘¨ |

---

## ä¹ã€å…³é”®ä»£ç ä½ç½®æ ‡è®°

### éœ€è¦ä¿®æ”¹çš„å…³é”®æ–‡ä»¶

1. **[collision_detection_pipeline_yolo_first_method_a.py](collision_detection_pipeline_yolo_first_method_a.py)**
   - Line 791-792: ä¸­å¿ƒç‚¹è·ç¦»è®¡ç®— â† **æ›¿æ¢ä¸ºå¤šé”šç‚¹**
   - Line 800-850: äº‹ä»¶è®°å½•æ ¼å¼ â† **æ‰©å±•ä¿¡æ¯**

2. **éœ€è¦æ–°å¢æ–‡ä»¶**:
   - `anchor_points.py`: é”šç‚¹å®šä¹‰å’Œè®¡ç®—
   - `collision_analyzer.py`: ç¢°æ’åˆ†æé€»è¾‘
   - `heading_estimator.py`: æœå‘ä¼°è®¡

---

## åã€å¯è§†åŒ–å»ºè®®

### æ”¹è¿›åçš„å¯è§†åŒ–è¾“å‡º

```python
# åœ¨å…³é”®å¸§å›¾åƒä¸Šç»˜åˆ¶
# å½“å‰: ä»…ç»˜åˆ¶ä¸­å¿ƒç‚¹è¿çº¿
# æ”¹è¿›: 
#   1. ç»˜åˆ¶æ‰€æœ‰é”šç‚¹ï¼ˆçº¢è‰²å°åœ†ï¼‰
#   2. çªå‡ºæœ€æ¥è¿‘çš„ä¸¤ä¸ªé”šç‚¹ï¼ˆå¤§ç»¿åœ†ï¼‰
#   3. æ ‡æ³¨éƒ¨ä½åç§°ï¼ˆ"rear_left", "front_right"ï¼‰
#   4. æ˜¾ç¤ºå…³é”®è·ç¦»å’Œé£é™©ç­‰çº§
#   5. æ˜¾ç¤ºè½¦è¾†æœå‘ç®­å¤´ï¼ˆè¡¨ç¤ºå‰è¿›æ–¹å‘ï¼‰

def draw_advanced_collision_analysis(frame, obj1, obj2, anchors1, anchors2, min_info):
    """
    åœ¨å…³é”®å¸§ä¸Šç»˜åˆ¶æ”¹è¿›çš„ç¢°æ’åˆ†æ
    
    ç»˜åˆ¶å†…å®¹ï¼š
    - è½¦è¾†çš„æ‰€æœ‰é”šç‚¹
    - æœ€æ¥è¿‘çš„ä¸¤ä¸ªé”šç‚¹ç”¨ç²—çº¿è¿æ¥
    - éƒ¨ä½åç§°æ ‡æ³¨
    - è·ç¦»æ•°å€¼
    - é£é™©ç­‰çº§å’Œç®­å¤´
    """
    # ç»˜åˆ¶ obj1 çš„æ‰€æœ‰é”šç‚¹
    for anchor_name, (px, py) in anchors1.items():
        cv2.circle(frame, (int(px), int(py)), 3, (0, 255, 0), -1)  # ç»¿è‰²
        cv2.putText(frame, anchor_name, (int(px)+5, int(py)-5),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 0), 1)
    
    # ç»˜åˆ¶ obj2 çš„æ‰€æœ‰é”šç‚¹
    for anchor_name, (px, py) in anchors2.items():
        cv2.circle(frame, (int(px), int(py)), 3, (255, 0, 0), -1)  # è“è‰²
    
    # ç”¨ç²—çº¿è¿æ¥æœ€æ¥è¿‘çš„ä¸¤ä¸ªé”šç‚¹
    pt1 = anchors1[min_info['part1']]
    pt2 = anchors2[min_info['part2']]
    cv2.line(frame, (int(pt1[0]), int(pt1[1])), (int(pt2[0]), int(pt2[1])), 
            (0, 0, 255), 3)  # ç²—çº¢çº¿
    
    # ç»˜åˆ¶æœå‘ç®­å¤´ï¼ˆè¡¨ç¤ºå‰è¿›æ–¹å‘ï¼‰
    # ... (çœç•¥)
    
    return frame
```

---

## åä¸€ã€æ€»ç»“å’Œå»ºè®®

### æ ¸å¿ƒæ”¹è¿›ç‚¹

| æ–¹é¢ | å½“å‰çŠ¶æ€ | æ”¹è¿›å | æ”¶ç›Š |
|------|---------|--------|------|
| **è·ç¦»è®¡ç®—** | ä¸­å¿ƒç‚¹æ¬§æ°è·ç¦» | å¤šé”šç‚¹æœ€å°è·ç¦» | æ›´ç²¾ç¡®æ£€æµ‹ç¢°æ’é£é™© |
| **é£é™©å®šä½** | "ä¸¤è½¦è·ç¦»Xç±³" | "çš®å¡å·¦å â†” å°è½¦è½¦å¤´å³" | å…·ä½“æŒ‡å‡ºç¢°æ’ä½ç½® |
| **æœå‘ä¿¡æ¯** | æ—  | åŸºäºè½¨è¿¹æ¨æ–­ | åˆ¤æ–­æ¥è¿‘æ–¹å‘ |
| **åº”ç”¨èŒƒå›´** | ä»…è½¦-è½¦ | è½¦-äººã€è½¦-è‡ªè¡Œè½¦ | é€‚ç”¨æ›´å¤šåœºæ™¯ |

### ç«‹å³å¯åšçš„å·¥ä½œï¼ˆæ— éœ€ä»£ç ï¼‰

âœ… **å®Œæˆåˆ†ææ–‡æ¡£** â† ä½ å·²ç»å®Œæˆäº†ï¼  
âœ… **æ ‡æ³¨è®­ç»ƒæ•°æ®** - ä¸ºå¤šä¸ªåœºæ™¯æ”¶é›†é”šç‚¹æ ‡æ³¨  
âœ… **è®¾è®¡æ–°çš„æ•°æ®æ ¼å¼** - JSON Schema å®šä¹‰  
âœ… **è§„åˆ’å¯è§†åŒ–æ–¹æ¡ˆ** - è®¾è®¡æ–°çš„æ³¨é‡Šæ–¹å¼

### ä¸‹ä¸€æ­¥ä»£ç å®ç°å»ºè®®

1. **åˆ›å»º `anchor_points.py`** - å®šä¹‰å„ç±»ç‰©ä½“çš„é”šç‚¹
2. **åˆ›å»º `collision_analyzer.py`** - å®ç°å¤šé”šç‚¹è·ç¦»è®¡ç®—
3. **ä¿®æ”¹ `collision_detection_pipeline_yolo_first_method_a.py`**:
   - åœ¨ `extract_key_frames()` ä¸­é›†æˆæ–°çš„è·ç¦»è®¡ç®—
   - æ›´æ–°äº‹ä»¶è®°å½•æ ¼å¼
   - æ·»åŠ å¯è§†åŒ–å‡½æ•°
4. **å›å½’æµ‹è¯•** - ä¸ç°æœ‰æµ‹è¯•åœºæ™¯å¯¹æ¯”

---

## é™„ï¼šåè¯å¯¹ç…§è¡¨

| ä¸­æ–‡ | è‹±æ–‡ | è§£é‡Š |
|-----|------|------|
| é”šç‚¹ | Anchor Point | ç‰©ä½“ä¸Šçš„å…³é”®ä½ç½®ç‚¹ |
| æœå‘ | Heading / Orientation | è½¦è¾†å‰è¿›æ–¹å‘çš„è§’åº¦ |
| æŠ•å½± | Projection | å°†3Dä¿¡æ¯æŠ•å½±åˆ°2Då›¾åƒå¹³é¢ |
| é½æ¬¡å˜æ¢ | Homography | äºŒç»´å°„å½±å˜æ¢ï¼Œå°†åƒç´ åæ ‡è½¬ä¸–ç•Œåæ ‡ |
| éƒ¨ä½ | Part | ç‰©ä½“çš„æŸä¸ªå…·ä½“éƒ¨åˆ†ï¼ˆå¦‚"è½¦å¤´å·¦è§’"ï¼‰ |
| TTC | Time To Collision | é¢„è®¡ç¢°æ’æ—¶é—´ |
| ç¢°æ’é£é™© | Collision Risk | è¯„ä¼°ä¸¤ç‰©ä½“ç¢°æ’çš„å¯èƒ½æ€§ |

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2025-01-09  
**å»ºè®®å®¡é˜…äºº**: å¯¼å¸ˆ/æŠ€æœ¯è´Ÿè´£äºº  
**ä¸‹ä¸€æ­¥**: ç­‰å¾…åé¦ˆåè¿›å…¥ä»£ç å®ç°é˜¶æ®µ

