# Ultralytics ðŸš€ AGPL-3.0 License - https://ultralytics.com/license

# KITTI Stereo Detection dataset by Karlsruhe Institute of Technology and Toyota Technological Institute at Chicago
# Documentation: https://www.cvlibs.net/datasets/kitti/
# Example usage: yolo train data=kitti-stereo.yaml
#
# Label format: class_id xl yl wl hl xr yr wr hr dim_l dim_w dim_h loc_x loc_y loc_z rot_y kp1_x kp1_y kp2_x kp2_y kp3_x kp3_y kp4_x kp4_y
# Where: xl,yl,wl,hl = left 2D box (normalized), xr,yr,wr,hr = right 2D box (normalized)
#        dim_l,dim_w,dim_h = 3D dimensions, loc_x,loc_y,loc_z = 3D location, rot_y = rotation
#        kp1-4 = 4 keypoints (corners of 2D box in normalized coordinates)
# parent
# â”œâ”€â”€ ultralytics
# â””â”€â”€ datasets
#     â””â”€â”€ kitti-stereo â† downloads here (~175 GB for full dataset)

# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
path: kitti-stereo # dataset root dir
train: images/train/left # train images (left stereo) (relative to 'path') 
val: images/val/left # val images (left stereo) (relative to 'path')

# Stereo image pairs (optional, for stereo-based 3D detection)
train_right: images/train/right # train images (right stereo) (relative to 'path')
val_right: images/val/right # val images (right stereo) (relative to 'path')

# Classes (same as KITTI detection)
names:
  0: car
  1: van
  2: truck
  3: pedestrian
  4: person_sitting
  5: cyclist
  6: tram
  7: misc

# Download script/URL (optional)
download: |
  import os
  import shutil
  from pathlib import Path
  
  from ultralytics.utils import LOGGER, TQDM
  from ultralytics.utils.downloads import download, safe_download
  
  def convert_kitti_to_yolo_stereo(kitti_root: Path, output_dir: Path, split: str = "training"):
      """Convert KITTI dataset to YOLO format with stereo support.
      
      Args:
          kitti_root: Path to raw KITTI dataset root (contains 'training' and 'testing' folders)
          output_dir: Path to output directory for converted dataset
          split: 'training' or 'testing'
      """
      kitti_dir = kitti_root / split
      if not kitti_dir.exists():
          LOGGER.warning(f"KITTI {split} directory not found: {kitti_dir}")
          return
      
      # Create output directories
      for subset in ["train", "val"]:
          for side in ["left", "right"]:
              (output_dir / "images" / subset / side).mkdir(parents=True, exist_ok=True)
          (output_dir / "labels" / subset).mkdir(parents=True, exist_ok=True)
          (output_dir / "calib" / subset).mkdir(parents=True, exist_ok=True)
      
      # Get all image files
      left_images = sorted((kitti_dir / "image_2").glob("*.png"))
      right_images = sorted((kitti_dir / "image_3").glob("*.png"))
      
      if not left_images:
          LOGGER.warning(f"No images found in {kitti_dir / 'image_2'}")
          return
      
      # Split into train/val (80/20 split)
      n_total = len(left_images)
      n_train = int(n_total * 0.8)
      
      train_left = left_images[:n_train]
      train_right = right_images[:n_train] if len(right_images) >= n_train else []
      val_left = left_images[n_train:]
      val_right = right_images[n_train:] if len(right_images) > n_train else []
      
      # Process training set
      LOGGER.info(f"Processing {len(train_left)} training images...")
      for i, left_img in enumerate(TQDM(train_left, desc="Converting training set")):
          img_id = left_img.stem
          
          # Copy left image
          shutil.copy2(left_img, output_dir / "images" / "train" / "left" / f"{img_id}.png")
          
          # Copy right image if available
          if i < len(train_right) and train_right[i].exists():
              shutil.copy2(train_right[i], output_dir / "images" / "train" / "right" / f"{img_id}.png")
          
          # Convert label
          label_file = kitti_dir / "label_2" / f"{img_id}.txt"
          calib_file = kitti_dir / "calib" / f"{img_id}.txt"
          if label_file.exists():
              yolo_label = output_dir / "labels" / "train" / f"{img_id}.txt"
              convert_kitti_label_to_yolo(label_file, yolo_label, left_img, calib_file)
          
          # Copy calibration file
          if calib_file.exists():
              shutil.copy2(calib_file, output_dir / "calib" / "train" / f"{img_id}.txt")
      
      # Process validation set
      LOGGER.info(f"Processing {len(val_left)} validation images...")
      for i, left_img in enumerate(TQDM(val_left, desc="Converting validation set")):
          img_id = left_img.stem
          
          # Copy left image
          shutil.copy2(left_img, output_dir / "images" / "val" / "left" / f"{img_id}.png")
          
          # Copy right image if available
          if i < len(val_right) and val_right[i].exists():
              shutil.copy2(val_right[i], output_dir / "images" / "val" / "right" / f"{img_id}.png")
          
          # Convert label
          label_file = kitti_dir / "label_2" / f"{img_id}.txt"
          calib_file = kitti_dir / "calib" / f"{img_id}.txt"
          if label_file.exists():
              yolo_label = output_dir / "labels" / "val" / f"{img_id}.txt"
              convert_kitti_label_to_yolo(label_file, yolo_label, left_img, calib_file)
          
          # Copy calibration file
          if calib_file.exists():
              shutil.copy2(calib_file, output_dir / "calib" / "val" / f"{img_id}.txt")
      
      LOGGER.info(f"Conversion complete! Train: {len(train_left)}, Val: {len(val_left)}")
  
  
  def convert_kitti_label_to_yolo(kitti_label: Path, yolo_label: Path, img_path: Path, calib_file: Path = None):
      """Convert KITTI label format to stereo 3D detection format.
      
      KITTI format: class truncated occluded alpha bbox_x1 bbox_y1 bbox_x2 bbox_y2 height width length x y z rotation_y
      Output format: class_id xl yl wl hl xr yr wr hr dim_l dim_w dim_h loc_x loc_y loc_z rot_y kp1_x kp1_y kp2_x kp2_y kp3_x kp3_y kp4_x kp4_y
      
      Args:
          kitti_label: Path to KITTI format label file
          yolo_label: Path to output label file
          img_path: Path to corresponding left image (for dimensions)
          calib_file: Path to calibration file (for right camera projection)
      """
      import cv2
      import numpy as np
      
      # Read image dimensions
      img = cv2.imread(str(img_path))
      if img is None:
          LOGGER.warning(f"Could not read image: {img_path}")
          return
      img_h, img_w = img.shape[:2]
      
      # Parse calibration file
      P2 = None  # Left camera projection matrix
      P3 = None  # Right camera projection matrix
      R0_rect = None
      
      if calib_file and calib_file.exists():
          with open(calib_file, "r") as f:
              for line in f:
                  if line.startswith("P2:"):
                      P2 = np.array([float(x) for x in line.split()[1:]]).reshape(3, 4)
                  elif line.startswith("P3:"):
                      P3 = np.array([float(x) for x in line.split()[1:]]).reshape(3, 4)
                  elif line.startswith("R0_rect:"):
                      R0_rect = np.array([float(x) for x in line.split()[1:]]).reshape(3, 3)
      
      # Class mapping (KITTI to output)
      class_map = {
          "Car": 0, "Van": 1, "Truck": 2,
          "Pedestrian": 3, "Person_sitting": 4,
          "Cyclist": 5, "Tram": 6, "Misc": 7,
          "DontCare": -1  # Skip DontCare
      }
      
      def project_3d_to_2d(x, y, z, h, w, l, rot_y, P):
          """Project 3D box to 2D image plane.
          
          KITTI coordinate system (camera):
          - x: right, y: down, z: forward
          - Box dimensions: h (height), w (width), l (length)
          - Box center at (x, y, z), rotated by rot_y around y-axis
          """
          # Compute 8 corners of 3D box in object coordinate system (centered at origin)
          # Order: [front-left-top, front-right-top, back-right-top, back-left-top,
          #         front-left-bottom, front-right-bottom, back-right-bottom, back-left-bottom]
          # x: right (width)
          # y: down (height)  
          # z: forward (length)
          corners_3d_obj = np.array([
              [-w/2, w/2, w/2, -w/2, -w/2, w/2, w/2, -w/2],   # x (right)
              [-h/2, -h/2, -h/2, -h/2, h/2, h/2, h/2, h/2],   # y (down)
              [l/2, l/2, -l/2, -l/2, l/2, l/2, -l/2, -l/2]    # z (forward)
          ])
          
          # Rotation matrix around y-axis
          R = np.array([
              [np.cos(rot_y), 0, np.sin(rot_y)],
              [0, 1, 0],
              [-np.sin(rot_y), 0, np.cos(rot_y)]
          ])
          
          # Rotate corners
          corners_3d = R @ corners_3d_obj
          
          # Translate to world position
          corners_3d[0, :] += x
          corners_3d[1, :] += y
          corners_3d[2, :] += z
          
          # Apply R0_rect if available (rectification matrix)
          if R0_rect is not None:
              corners_3d_rect = R0_rect @ corners_3d
          else:
              corners_3d_rect = corners_3d
          
          # Homogeneous coordinates
          corners_3d_homo = np.vstack([corners_3d_rect, np.ones((1, 8))])
          
          # Project to image plane
          corners_2d = P @ corners_3d_homo
          corners_2d = corners_2d[:2, :] / (corners_2d[2, :] + 1e-8)  # Avoid division by zero
          
          return corners_2d.T
      
      yolo_lines = []
      with open(kitti_label, "r") as f:
          for line in f:
              parts = line.strip().split()
              if not parts or len(parts) < 15:
                  continue
              
              class_name = parts[0]
              if class_name == "DontCare":
                  continue
              
              if class_name not in class_map:
                  continue
              
              cls_id = class_map[class_name]
              
              # Extract left 2D bounding box (x1, y1, x2, y2) - already in image coordinates
              x1_l, y1_l, x2_l, y2_l = map(float, parts[4:8])
              
              # Extract 3D attributes
              dim_h = float(parts[8])   # height
              dim_w = float(parts[9])   # width
              dim_l = float(parts[10])  # length
              loc_x = float(parts[11])  # x
              loc_y = float(parts[12])  # y
              loc_z = float(parts[13])  # z
              rot_y = float(parts[14]) # rotation_y
              
              # Normalize left 2D box
              xl = ((x1_l + x2_l) / 2.0) / img_w
              yl = ((y1_l + y2_l) / 2.0) / img_h
              wl = (x2_l - x1_l) / img_w
              hl = (y2_l - y1_l) / img_h
              
              # Project to right camera if calibration available
              if P2 is not None and P3 is not None:
                  try:
                      corners_2d_right = project_3d_to_2d(loc_x, loc_y, loc_z, dim_h, dim_w, dim_l, rot_y, P3)
                      x_coords = corners_2d_right[:, 0]
                      y_coords = corners_2d_right[:, 1]
                      x1_r = np.min(x_coords)
                      y1_r = np.min(y_coords)
                      x2_r = np.max(x_coords)
                      y2_r = np.max(y_coords)
                      
                      # Normalize right 2D box
                      xr = ((x1_r + x2_r) / 2.0) / img_w
                      yr = ((y1_r + y2_r) / 2.0) / img_h
                      wr = (x2_r - x1_r) / img_w
                      hr = (y2_r - y1_r) / img_h
                  except:
                      # Fallback: use left box for right (with slight offset)
                      xr, yr, wr, hr = xl - 0.01, yl, wl, hl
              else:
                  # Fallback: use left box for right (with slight offset)
                  xr, yr, wr, hr = xl - 0.01, yl, wl, hl
              
              # Compute keypoints (4 corners of left 2D box in normalized coordinates)
              kp1_x = x1_l / img_w  # top-left
              kp1_y = y1_l / img_h
              kp2_x = x2_l / img_w  # top-right
              kp2_y = y1_l / img_h
              kp3_x = x2_l / img_w  # bottom-right
              kp3_y = y2_l / img_h
              kp4_x = x1_l / img_w  # bottom-left
              kp4_y = y2_l / img_h
              
              # Ensure normalized values are in [0, 1]
              xl = max(0, min(1, xl))
              yl = max(0, min(1, yl))
              wl = max(0, min(1, wl))
              hl = max(0, min(1, hl))
              xr = max(0, min(1, xr))
              yr = max(0, min(1, yr))
              wr = max(0, min(1, wr))
              hr = max(0, min(1, hr))
              
              # Format: class_id xl yl wl hl xr yr wr hr dim_l dim_w dim_h loc_x loc_y loc_z rot_y kp1_x kp1_y kp2_x kp2_y kp3_x kp3_y kp4_x kp4_y
              yolo_lines.append(
                  f"{cls_id} {xl:.6f} {yl:.6f} {wl:.6f} {hl:.6f} "
                  f"{xr:.6f} {yr:.6f} {wr:.6f} {hr:.6f} "
                  f"{dim_l:.6f} {dim_w:.6f} {dim_h:.6f} "
                  f"{loc_x:.6f} {loc_y:.6f} {loc_z:.6f} {rot_y:.6f} "
                  f"{kp1_x:.6f} {kp1_y:.6f} {kp2_x:.6f} {kp2_y:.6f} "
                  f"{kp3_x:.6f} {kp3_y:.6f} {kp4_x:.6f} {kp4_y:.6f}\n"
              )
      
      # Write output label
      with open(yolo_label, "w") as f:
          f.writelines(yolo_lines)
  
  
  # Main download and conversion logic
  dir = Path(yaml["path"])  # dataset root dir
  
  LOGGER.info("=" * 60)
  LOGGER.info("KITTI Stereo Dataset Download and Conversion")
  LOGGER.info("=" * 60)
  LOGGER.info("")
  
  # KITTI dataset S3 URLs
  kitti_urls = {
      "image_2": "https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_image_2.zip",  # left images
      "image_3": "https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_image_3.zip",  # right images
      "label_2": "https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_label_2.zip",  # labels
      "calib": "https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_calib.zip",  # calibration
  }
  
  def reorganize_kitti_structure(root_path: Path):
      """Reorganize KITTI files if they were extracted to wrong locations.
      
      Moves files from data_object_*/training/ to training/ directory.
      """
      training_dir = root_path / "training"
      training_dir.mkdir(parents=True, exist_ok=True)
      
      # Map of source directories to target subdirectories
      reorganize_map = {
          "data_object_image_2": ("training", "image_2"),
          "data_object_image_3": ("training", "image_3"),
          "data_object_label_2": ("training", "label_2"),
          "data_object_calib": ("training", "calib"),
      }
      
      for src_dir_name, (split, target_subdir) in reorganize_map.items():
          src_dir = root_path / src_dir_name / split / target_subdir
          dest_dir = training_dir / target_subdir
          
          if src_dir.exists():
              if dest_dir.exists():
                  # Merge directories if both exist
                  LOGGER.info(f"Merging {src_dir_name}/{split}/{target_subdir} into training/{target_subdir}...")
                  for item in src_dir.iterdir():
                      dest_item = dest_dir / item.name
                      if item.is_file():
                          if not dest_item.exists():
                              shutil.copy2(item, dest_item)
                      elif item.is_dir():
                          if dest_item.exists():
                              # Recursively merge
                              for subitem in item.rglob("*"):
                                  rel_path = subitem.relative_to(item)
                                  dest_subitem = dest_item / rel_path
                                  dest_subitem.parent.mkdir(parents=True, exist_ok=True)
                                  if subitem.is_file() and not dest_subitem.exists():
                                      shutil.copy2(subitem, dest_subitem)
                          else:
                              shutil.move(str(item), str(dest_item))
                  # Remove source directory after merging
                  try:
                      shutil.rmtree(src_dir.parent.parent)  # Remove the data_object_* directory
                  except:
                      pass
              else:
                  LOGGER.info(f"Moving {src_dir_name}/{split}/{target_subdir} to training/{target_subdir}...")
                  dest_dir.parent.mkdir(parents=True, exist_ok=True)
                  shutil.move(str(src_dir), str(dest_dir))
                  LOGGER.info(f"Moved {target_subdir} successfully")
                  # Try to remove parent directories if empty
                  try:
                      if not any((src_dir.parent.parent).iterdir()):
                          shutil.rmtree(src_dir.parent.parent)
                  except:
                      pass
  
  def check_files_exist(root_path: Path) -> bool:
      """Check if KITTI files are already downloaded (as zip or extracted)."""
      # Check for zip files
      zip_files = [
          root_path / "data_object_image_2.zip",
          root_path / "data_object_image_3.zip",
          root_path / "data_object_label_2.zip",
          root_path / "data_object_calib.zip",
      ]
      if all(zf.exists() for zf in zip_files):
          return True
      
      # Check for extracted directories (either in correct or wrong location)
      extracted_dirs = [
          root_path / "training" / "image_2",
          root_path / "data_object_image_2" / "training" / "image_2",
      ]
      if any(ed.exists() and list(ed.glob("*.png")) for ed in extracted_dirs):
          return True
      
      return False
  
  # Check for KITTI_ROOT environment variable or use default
  kitti_root = os.getenv("KITTI_ROOT")
  if kitti_root:
      kitti_root = Path(kitti_root)
      LOGGER.info(f"Using KITTI_ROOT: {kitti_root}")
  else:
      # Try to find KITTI dataset in common locations
      possible_paths = [
          dir.parent / "kitti_raw",
          dir.parent / "kitti",
          Path.home() / "datasets" / "kitti",
          Path("/data") / "kitti",
      ]
      
      kitti_root = None
      for p in possible_paths:
          if p.exists():
              # Check if files exist (either correctly organized or need reorganization)
              if check_files_exist(p):
                  kitti_root = p
                  LOGGER.info(f"Found KITTI dataset at: {kitti_root}")
                  break
              # Also check for correct structure
              if (p / "training" / "image_2").exists():
                  kitti_root = p
                  LOGGER.info(f"Found KITTI dataset at: {kitti_root}")
                  break
  
  # Set default location if not found
  if kitti_root is None:
      kitti_root = dir.parent / "kitti_raw"
  
  kitti_root.mkdir(parents=True, exist_ok=True)
  
  # Check if files already exist
  files_exist = check_files_exist(kitti_root)
  correct_structure = (kitti_root / "training" / "image_2").exists()
  
  if files_exist and not correct_structure:
      LOGGER.info("Found downloaded files but in wrong structure. Reorganizing...")
      reorganize_kitti_structure(kitti_root)
      correct_structure = (kitti_root / "training" / "image_2").exists()
  
  # Download and extract if not found
  if not files_exist:
      LOGGER.info("KITTI dataset not found. Downloading from S3...")
      LOGGER.info("This may take a while (several GB to download)...")
      
      # Download and extract each zip file directly to kitti_root
      # Each zip extracts to training/ and testing/ directories which will merge
      for key, url in TQDM(kitti_urls.items(), desc="Downloading KITTI files"):
          LOGGER.info(f"Downloading {key} from {url}...")
          # Download and extract - files will merge into training/ and testing/ directories
          download(url, kitti_root, unzip=True, delete=True, exist_ok=True)
      
      # Reorganize if needed
      if not (kitti_root / "training" / "image_2").exists():
          reorganize_kitti_structure(kitti_root)
      
      LOGGER.info(f"Download and extraction complete! Dataset at: {kitti_root}")
  elif files_exist:
      LOGGER.info(f"Using existing KITTI dataset at: {kitti_root}")
  
  # Verify KITTI structure
  if not (kitti_root / "training" / "image_2").exists():
      raise FileNotFoundError(f"KITTI training images not found at {kitti_root / 'training' / 'image_2'}. Please check the dataset structure.")
  
  # Convert dataset
  LOGGER.info(f"Converting KITTI dataset from {kitti_root} to {dir}...")
  convert_kitti_to_yolo_stereo(kitti_root, dir, split="training")
  
  LOGGER.info("")
  LOGGER.info("=" * 60)
  LOGGER.info("KITTI Stereo Dataset Conversion Complete!")
  LOGGER.info(f"Dataset saved to: {dir}")
  LOGGER.info("=" * 60)

